; -----------------------------------------------------------------------
; Template source file generated by piklab
    #include <p16f690.inc>

; -----------------------------------------------------------------------
; Configuration bits: adapt to your setup and needs
    __CONFIG _INTOSCIO & _WDT_OFF & _PWRTE_OFF & _MCLRE_OFF & _CP_OFF & _CPD_OFF & _BOR_ON & _IESO_ON & _FCMEN_ON

; -----------------------------------------------------------------------
; Változó értékadás
INT_VAR UDATA_SHR
time1		RES 1
time2		RES 1
time3		RES 1
time4		RES 1
time5		RES 1
time6		RES 1
buttonholdinghi	RES 1
buttonholdinglo RES 1
porttmp		RES 1
motorstate	RES 1
stepbit		RES 1
stepxor		RES 1
positionhi	RES 1
positionlo	RES 1
graceperiod	RES 1


EXPLOSURE_COEFFICIENT EQU d'126'
BUTTON_HOLDING_COUNTER EQU 0x08

; RA2	IN+PU	bumper sensor
; RA4	IN+PU	^button
; RC0	OUT	bumper opto LED
; RC1	OUT	LED
; RC2	OUT	lamp

; RC4	OUT	MOTOR orange
; RC5	OUT	MOTOR yellow
; RC6	OUT	MOTOR brown
; RC7	OUT	MOTOR black

; forward	= direction to PCB
; backward	= direction to bumper

; maximal position: 0x0718

; details of schematics and building from PRIMAX Colorado Direct scanner:
; original main PCB is totally removed
; the new PCB and the camera board are grounded together
; a 78l05 IC is used for providing 5V source for the uC
; you need also an ULN2003 sink driver IC and a p-mosfet likely IRF9540
; RA2 is connected to the opto sensor, and a 200K resistor pulls it up to 5V and a 4.7nF capacitor connects it to common GND
; RA4 is connected to the button, the other wire of the button should be grounded
; RC0 is connected to opto LED (the one with a resistor in serial on the PCB)
; RC1 is connected to green LED with an 1K resistor in serial. the other wire of the LED is grounded
; RC2 is connected to the gate of the mosfet through an ULN2003 driver. the drain is connected to +12V, the source is connected to the camera board +12V wire. a 100K resistor connected to the gate and the source of the mosfet
; RC4-RC7 are connected to appropriate motor wires through ULN2003 driver blocks. the red wire is connected to +12V

; -----------------------------------------------------------------------
; reset vector
STARTUP CODE 0x000
start
    movlw	b'00000011'		; motor off, lamp off, LED on, bumper opto LED on
    movwf	PORTC
    bsf		STATUS,RP1
    clrf	ANSEL			; all inputs are digital
    clrf	ANSELH
    bcf		STATUS,RP1
    bsf		STATUS,RP0
    movlw	b'00001000'		; define 6 outputs on PORTC
    movwf	TRISC
    bcf		WPUA,2			; RA2 no pull-up
    bcf		OPTION_REG,NOT_RABPU	; global enable pull-ups
    bsf		STATUS,RP1
    bsf		EECON1,WREN
    bsf		EECON1,RD
    nop					; using strict formula
    nop
    bcf		STATUS,RP0
    movf	EEDAT,w
    bcf		STATUS,RP1
    movwf	motorstate
    clrf	time1
    clrf	graceperiod

querystate
    call	delay1			; wait for the capacitor to be charged
    btfss	PORTA,2			; bumped?
    goto	powerrestore		; no

bumped
    bcf		PORTC,0			; opto LED off
    clrf	positionhi		; reset position
    clrf	positionlo

waitForButton1
    btfsc	PORTA,4			; button pressed?
    goto	waitForButton1
    bsf		PORTC,2			; lamp on
    
forward1				; move forward while the button pressed
    call	stepfw
    btfsc	PORTA,4			; button released?
    goto	endofforward1
    movlw	0x07			; check for end position 0x0718
    xorwf	positionhi,w
    btfss	STATUS,Z
    goto	forward1
    movlw	0x18
    xorwf	positionlo,w
    btfss	STATUS,Z
    goto	forward1		; step again if end position not reached

waitForButton2
    btfss	PORTA,4			; wait for button to be released
    goto	waitForButton2		; in case of end position

endofforward1
    call	delay1			; wait for button to be settled
    incf	graceperiod,f		; grant the grace period
					; when user can induce individual steps with the button
powerrestore
    movlw	b'00000111'		; lamp, LED and opto LED on
    movwf	PORTC			; in any case (power restore)

;	doing the slow motion backward
    clrf	time5

motion
    movlw	EXPLOSURE_COEFFICIENT	; you can change this coefficient in the header
    movwf	time6
    
del2
    decfsz	time4,f			; just a short delay
    goto	del2
    btfss	PORTA,4			; button pressed?
    goto	manipulation		; yes, the progress is being manipulated
returnfrommanipulation
    btfss	PORTA,4			; if button released
    goto	dontreset
    movlw	BUTTON_HOLDING_COUNTER
    movwf	buttonholdinghi		; reset button holding counter
    clrf	buttonholdinglo
dontreset
    decfsz	time5,f			; 256 times more delay
    goto	del2
    movlw	b'00000010'
    xorwf	PORTC,f			; blink LED
    btfsc	PORTA,2			; bumped?
    goto	restart			; if yes, dont step again, end of procedure
    decfsz	time6,f			; decrease explosure counter
    goto	del2			; it's not time for a step yet
    call	stepbw			; step backward
    bcf		graceperiod,0		; grace period is over
    goto	motion			; wait and move again
    
manipulation
    btfsc	buttonholdinglo,7	; only step once when button just pressed
    goto	ignorestep
    btfsc	graceperiod,0		; grace period over?
    call	stepbw			; if no, step backward
ignorestep    
    decf	buttonholdinglo,f	; counting down the holding time
    btfsc	buttonholdinglo,7
    goto	returnfrommanipulation
    bsf		buttonholdinglo,7
    decfsz	buttonholdinghi,f		
    goto	returnfrommanipulation
    movlw	b'00000011'
    movwf	PORTC			; lamp off, LED and opto LED on
initial
    call	stepbw			; move back to initial position
    btfss	PORTA,2			; bumped?
    goto	initial
    goto	restart			; job cancelled, start from beginning
    
delay1
    clrw
delay
    movwf	time2
del1
    decfsz	time1,f
    goto	del1
    decfsz	time2,f
    goto	del1
    return

stepfw					; one step forward
    movlw	b'00010000'
    movwf	stepbit
    movlw	b'00110000'
    movwf	stepxor
    incf	positionhi,f		; increment position counter
    incfsz	positionlo,f
    decf	positionhi,f
    goto	stepp
stepbw					; one step backward
    movlw	b'10000000'
    movwf	stepbit
    movlw	b'11000000'
    movwf	stepxor
    decf	positionhi,f		; decrement position counter
    decf	positionlo,f
    incfsz	positionlo,w
    incf	positionhi,f
stepp					; the stepping action itself
    movf	PORTC,w
    movwf	porttmp
    iorwf	stepbit,w
    btfsc	motorstate,0
    xorwf	stepxor,w
    movwf	PORTC
    call	stepdelay
    movf	porttmp,w
    movwf	PORTC
    comf	motorstate,f		; changing the motor state value
    movf	motorstate,w
    bsf		STATUS,RP1
    movwf	EEDAT			; storing motor state to flash memory
    bsf		STATUS,RP0
    movlw	0x55			; using strict formula
    movwf	EECON2
    movlw	0xaa
    movwf	EECON2
    bsf		EECON1,WR
    bcf		STATUS,RP0
    bcf		STATUS,RP1
    return
stepdelay
    movlw	0x20			; motor pulse
    call	delay
    return
    
restart
    call	stepbw			; step one more to be sure about bumper
btn
    btfss	PORTA,4			; wait for button to be released
    goto	btn
    call	delay1
    goto	start
    
END
